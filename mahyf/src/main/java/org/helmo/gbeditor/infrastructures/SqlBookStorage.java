package org.helmo.gbeditor.infrastructures;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.helmo.gbeditor.models.Author;
import org.helmo.gbeditor.models.Book;
import org.helmo.gbeditor.models.Choice;
import org.helmo.gbeditor.models.Isbn;
import org.helmo.gbeditor.models.Page;
import org.helmo.gbeditor.repositories.StorageException;
import org.helmo.gbeditor.repositories.StorageInterface;

/**
 * Permets d'intéragir avec la base de données
 * @author franc
 *
 */
public class SqlBookStorage  implements AutoCloseable, StorageInterface{
	  private final Connection connection;	  
	  private LibraryBooks libraryBooks;
	  private int matriculeAuthor = 0;
	  
	    private final static String CREATE_BOOK =
	    		"CREATE TABLE BOOK(" +
	                    "idBook INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
	                    "title VARCHAR(150) NOT NULL,"+
	                    "isbn VARCHAR(13) NOT NULL,"+
	                    "description VARCHAR(500) NOT NULL,"+
	                    "matricule INT NOT NULL,"+
	                    "isPublished boolean default false," +
	                    "FOREIGN KEY(matricule) REFERENCES AUTHOR(matricule))";
	    
	    private final static String CREATE_AUTHOR =
	    		"CREATE TABLE AUTHOR(" +
	    				"matricule INT,"+
	    				"firstName VARCHAR(50),"+
	    				"name VARCHAR(50),"+
	    				"PRIMARY KEY(matricule))";
	    
	    private final static String CREATE_PAGE =
	    		"CREATE TABLE Page(" + 
	    				   "idPage INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,"+
	    				   "numPage INT," +
	    				   "textPage VARCHAR(500),"+
	    				   "idBook INT NOT NULL,"+
	    				   "FOREIGN KEY(idBook) REFERENCES BOOK(idBook))";

	    private final static String CREATE_CHOICE = 
                "CREATE TABLE Choice("+
                        "idChoice INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,"+
                        "numChoice INT NOT NULL, " +
                        "textChoice VARCHAR(500),"+
                        "numFromPage INT NOT NULL,"+
                        "numGoPage INT NOT NULL," +
                        "idBook INT NOT NULL," +
                        "FOREIGN KEY(idBook) REFERENCES BOOK(idBook))";

	    private static final String INSERT_BOOK = 
	            "INSERT INTO BOOK(title, isbn, description, matricule) VALUES (?,?,?,?)";
	    
	    private static final String UPDATE_BOOK =
	            "UPDATE BOOK SET TITLE=?, ISBN=?, DESCRIPTION=? WHERE IDBOOK=?";
	    
	    private static final String UPDATE_PUBLISH = 
	    		"UPDATE BOOK SET ISPUBLISHED = TRUE WHERE IDBOOK = ?";    
	    
	    private static final String INSERT_AUTHOR = 
	            "INSERT INTO AUTHOR(matricule, firstName, name) VALUES (?,?,?)";

	    private static final String INSERT_PAGE = 
	            "INSERT INTO PAGE(numPage, textPage, idBook) VALUES (?,?, ?)";
	    
	    private static final String INSERT_CHOICE = 
	    		"INSERT INTO CHOICE(numChoice, textChoice, numFromPage, numGoPage, idBook) VALUES(?, ?, ?, ?, ?)";
	    
	    private static final String DELETE_PAGES = 
	    		"DELETE FROM PAGE WHERE idBook = ?";
	    
	    private static final String DELETE_CHOICE = 
	    		"DELETE FROM CHOICE WHERE numFromPage = ? AND idBook = ?";
	    	    
	    private static final String DELETE_CHOICES = 
	    		"DELETE FROM CHOICE WHERE idBook = ?";
	    
	    private static final String LOAD_LIBRABYBOOKS = 
	    		"SELECT idBook, title, isbn, description, isPublished, matricule  FROM BOOK WHERE matricule = ?";
	    
	    private static final String LOAD_PAGES = 
	    		"SELECT * FROM PAGE WHERE idBook = ?";
	    
	    private static final String LOAD_CHOICES = 
	    		"SELECT * FROM CHOICE WHERE numFromPage = ? AND idBook = ?";
	    
	    private static final String LOAD_AUTHOR = 
	    		"Select * from AUTHOR where matricule = ?";

		private static final String CHECK_AUTHOR = 
				"Select * from AUTHOR where matricule = ?";
		
		private static final String CHECK_ISBN_EXIST = 
				"Select * from BOOK where isbn LIKE ?";
	    
	    
	    /**
	     * Constructeur de SqlBookStorage
	     * @param con Connection qui est la connexion à la BD
	     */
	    public SqlBookStorage(Connection con) {
	        this.connection = con;
	    }
	    
	    /**
	     * Méthode qui permet de modifier le matricule de l'auteur
	     * @param matriculeAuthor int qui est le matricule de l'auteur
	     */
	    @Override
	    public void setMatriculeAuthor(int matriculeAuthor) {
	    		this.matriculeAuthor = matriculeAuthor;
	    }    
	    
	    /**
	     * Méthode qui permet d'assigner la librairie de livre au storage
	     * @param librabyBooks LibraryBooks qui est la bibliothèque des livres
	     */
		@Override
	    public void setLibrabyBooks(LibraryBooks librabyBooks) {
	    	this.libraryBooks = librabyBooks;
	    }
		
	   /**
	    * Méthode qui permet de récupérer l'ensemble des livres d'une bibliothèque
	    * @return List<Book> l'ensemble des livres d'un bibliothèque
	    */
		@Override
		public List<Book> getListBooks() {
			return new ArrayList<Book>(this.libraryBooks.getLibrabyBooks().keySet());
		}
		
		/**
		 * Méthode qui permet de récupérer un livre sur base de son numéro isbn
		 * @param isbn String le numéro isbn du livre
		 * @return Book le livre auquel appartient le numéro isbn
		 */
		@Override
		public Book getBook(String isbn) {
			return this.libraryBooks.getBook(isbn);
		}

	    /**
	     * Méthode qui permet de créer la base de données
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
	    public void setup() throws SQLException {
	        try (Statement createStatement = connection.createStatement()) {
	        	  createStatement.executeUpdate(CREATE_AUTHOR);
	        	  createStatement.executeUpdate(CREATE_BOOK);
	        	  createStatement.executeUpdate(CREATE_PAGE);
	        	  createStatement.executeUpdate(CREATE_CHOICE);
	        } catch (SQLException e) {
	        	throw new SQLException("Erreur lors de la création de la BD");
	        }
	    }

	    /**
	     * Méthode qui permet de supprimer la base de données
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
	    public void tearDown() throws SQLException {
	        try (Statement dropStatement = connection.createStatement()) {
	        	dropStatement.executeUpdate("DROP TABLE CHOICE");
	            dropStatement.executeUpdate("DROP TABLE PAGE");
	            dropStatement.executeUpdate("DROP TABLE BOOK");
	            dropStatement.executeUpdate("DROP TABLE AUTHOR");
	        } catch (SQLException e) {
	        	throw new SQLException("Erreur lors de la suppression de la BD \n");
	        }
	    }
	    
	    /**
	     * Méthode qui permet de d'enregistrer un auteur
	     * @param author Authro qui est l'auteur que l'on veut enregistrer
	     * @throws StorageException
	     */
	    @Override
	    public void saveAuthor(Author author) throws StorageException{
	    	 if(!checkIfAurthorExist(author)) {
	    		 try (PreparedStatement insertStmt = connection.prepareStatement(INSERT_AUTHOR)) {	        
	 	            insertStmt.setInt(1, author.getMatricule());
	 	        	insertStmt.setString(2, author.getFirstName());
	 	            insertStmt.setString(3, author.getName());
	 	            
	 	            insertStmt.executeUpdate();	     
	 	        }catch (SQLException e) {
					throw new StorageException("Erreur lors de la sauvegarde de l'auteur");
				}	  
	    	 }
	    }
	    
	    
	    /**
	     * Méthode qui permet d'insérer un Book dans la base de données 
	     * @param book Book qui est le livre que l'on souhaite ajouter
	     * @throws StorageException Exception lancée lors d'une erreur sql
	     */
	    @Override
	    public void insertBook(final Book book) throws StorageException {
	        try (PreparedStatement insertStmt = connection.prepareStatement(INSERT_BOOK, Statement.RETURN_GENERATED_KEYS)) {	        		           	            	        		        	
	            insertStmt.setString(1, book.getTitle());
	        	insertStmt.setString(2, book.getIsbn().getIsbnNumber());
	            insertStmt.setString(3, book.getResume());
	            insertStmt.setInt(4, book.getAuthor().getMatricule());	            
	            insertStmt.executeUpdate();	
	            
	            try(ResultSet rs = insertStmt.getGeneratedKeys()){
	            	 while(rs.next()) {
	 	            	this.libraryBooks.addBook(book, rs.getInt(1));	 	             
	 	            }
	            }          
	        }catch(SQLException e) {
	        	throw new StorageException("Erreur lors de l'écriture du livre." + e.getMessage() +"\n");
	        }
	    }
	   	    
	    /**
	     * Méthode qui permet d'insérer une Page dans la base de données
	     * @param page Page qui est la page que l'on souhaite ajouter
	     * @throws StorageException
	     */
	    private void insertPage(int idBook, final Page page) throws StorageException{
	    	 try (PreparedStatement insertStmt = connection.prepareStatement(INSERT_PAGE)) {
		            insertStmt.setInt(1, page.getNumPage());
		        	insertStmt.setString(2, page.getTextPage());
		        	insertStmt.setInt(3, idBook);
		            
		            insertStmt.execute();		
		            
		     }catch(SQLException e) {
		        	throw new StorageException("Erreur lors de l'écriture de la page." + e.getMessage() +"\n");
		     }
	    }

	    /**
	     * Méthode qui permet d'insérer un Choice dans la base de données
	     * @param choice
	     * @throws StorageException Exception lancée lors d'une erreur sql
	     */
	    @Override
	    public void insertChoice(final Choice choice, final Book book) throws StorageException{
	    	 try (PreparedStatement insertStmt = connection.prepareStatement(INSERT_CHOICE)) {
	    		 	insertStmt.setInt(1, choice.getNumChoice());
		            insertStmt.setString(2, choice.getTextChoice());
		        	insertStmt.setInt(3, choice.getNumFromPage());
		            insertStmt.setInt(4, choice.getNumGoToPage());
		            insertStmt.setInt(5, this.libraryBooks.getLibrabyBooks().get(book));
		            
		            insertStmt.executeUpdate();			            	           		            
		     }catch(SQLException e) {		  
		        	throw new StorageException("Erreur lors de l'écriture de du choix. " + e.getMessage()  +"\n");
		     }
	    }
	    
	    /** ENSEMBLE DES DELETES **/
	    
	    /**
	     * Méthode qui permet de supprimer toutes les pages liées à une livre
	     * @param idBook int id du livre 
	     * @param numPage int numéro de la page
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
	    private void deletePages(int idBook) throws SQLException{				
			 try(PreparedStatement updateStmt = connection.prepareStatement(DELETE_PAGES)) {
	             updateStmt.setInt(1, idBook);		             	             
	             updateStmt.executeUpdate();	             
	         }		
		}
	    
	    /**
	     * Méthode qui permet de mettre à jour les choix existants
	     */
	    @Override
	    public void updateChoices(int numPage, Book book, List<Choice> choiceList) {
	    	 Transaction
             .from(this.connection)
             .commit((con) -> this.updateChoicesTransaction(numPage, book, choiceList))
             .onRollback((ex) -> {throw new StorageException("Erreur lors de la supression du choix. " + ex.getMessage());})
             .execute();
	    }
	    

	    /**
	     * Méthode qui permet de mettre à jour les choix existants
	     * Elle va tous le ssupprimer et les rajouter
	     * @param numPage int qui est le numéro de la page dont on souhaite mettre à jour les choix
	     * @param book Book qui est le livre dont on souhaite mettre à jour les choix
	     * @param choiceList La liste des choix du livre
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
	    private void updateChoicesTransaction(int numPage, Book book, List<Choice> choiceList)throws SQLException {
	    	deleteChoice(numPage, this.libraryBooks.getLibrabyBooks().get(book));
	    	
	    	for(Choice choice : choiceList) {
	    		insertChoice(choice, book);
	    	}
	    }

	    /**
	     * Méthode qui permet de supprimer un choix
	     * @param idChoice int id du choix
	     * @throws SQLException 
	     * @throws  SQLException Exception lancée lors d'une erreur sql
	     */
		private void deleteChoice(int numPage, int idBook)throws SQLException{		
			
			 try(PreparedStatement updateStmt = connection.prepareStatement(DELETE_CHOICE)) {
	             updateStmt.setInt(1, numPage);	
	             updateStmt.setInt(2, idBook);
	             
	             updateStmt.executeUpdate();	             
	         }			 
		}
		
	    /**
	     * Méthode qui permet de supprimer tous les choix liés à une page
	     * @param numPage int le numéro de la page
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
	    private void deleteChoiceOnPageDelete(int idBook) throws SQLException{
	    	 try(PreparedStatement updateStmt = connection.prepareStatement(DELETE_CHOICES)) {
	 			
	             updateStmt.setInt(1, idBook);          
	             updateStmt.executeUpdate();	             
	         }	
	    }
	    
	    /** ENSEMBLE DES UPDATES **/
		
		/**
		 * Méthode qui permet de passer un livre comme publié
		 * @param idBook int id du livre
		 * @throws SQLException Exception lancée lors d'une erreur sql
		 */
	    @Override
	    public void updateBookPusblished(final Book book) throws StorageException{
	    	 try(PreparedStatement updateStmt = connection.prepareStatement(UPDATE_PUBLISH)) {	             
	             updateStmt.setInt(1, libraryBooks.getLibrabyBooks().get(book));
	           
	             updateStmt.executeUpdate();
	         }catch(SQLException e) {
	        	 throw new StorageException("Erreur lors de la publication du livre \n");
	         }
	    }
	    
	    /**
	     * Méthode qui permet de mettre à jour les informations de base d'un 
	     * livre dans la base de données
	     * @param idBook int id du livre
	     * @param title String tittre du livre
	     * @param isbn String numéro isbn du livre
	     * @param descirption String description du livre
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
	    @Override
	    public void updateBook(Book book, String title, String isbn, String descirption) throws StorageException{
	    	 try(PreparedStatement updateStmt = connection.prepareStatement(UPDATE_BOOK)) {
	             updateStmt.setString(1, title);
	             updateStmt.setString(2, isbn);
	             updateStmt.setString(3, descirption);
	             
	             updateStmt.setInt(4, libraryBooks.getLibrabyBooks().get(book));
	           
	             updateStmt.executeUpdate();
	             
	         	String isbnNumberOld = book.getIsbn().getIsbnNumber();							
				Book newBook = new Book(this.libraryBooks.getBook(isbnNumberOld));	
				newBook.updateBookInforamtion(title, isbn, descirption);
				this.libraryBooks.updateBook(isbnNumberOld, newBook);
				
	         }catch(SQLException e) {
	        	 throw new StorageException("Erreur lors de la mise à jour du livre \n");
	         }
	    }
	   	 	    
	    /**
	     * Méthode qui permet de mettre à jour toutes les pages d'un livre
	     * Méthode qui permet de mettre à jour toutes les pages d'un livre 
	     * @param idBook int id livre
	     * @param numPage int numéro de la page
	     * @param listPage SortedSet<Page> les pages du livre
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
	    @Override
		public void updatePages(Book book)throws StorageException {
			 Transaction
             .from(this.connection)
             .commit((con) -> this.updatePagesTransaction(book))
             .onRollback((ex) -> {throw new StorageException("Erreur lors de la mise à jours des pages du livre : " + ex.getMessage() + " \n");})
             .execute(); 
		}
		
	    /**
	     * Méthode qui permet de mettre à jour toutes les pages d'un livre 
	     * @param idBook int id livre
	     * @param numPage int numéro de la page
	     * @param listPage SortedSet<Page> les pages du livre
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
		private void updatePagesTransaction(Book book) throws SQLException {
			int idBook = this.libraryBooks.getLibrabyBooks().get(book);			
			deleteChoiceOnPageDelete(idBook);
			deletePages(idBook);
			for(Page page: book.getListPage()) {	
					insertPage(idBook, page);
					for(Choice choice : page.getChoiceList()) {
						insertChoice(choice, book);
					}					
			}
		}
		
		/**ENSEMBLE DES LOAD **/
		
		/**
		 * Méthode qui permet de lire tous les livres d'un auteur sur base de son matricule
		 * @return Map<Integer, Book> tous les livres d'un auteur
		 * @throws SQLException Exception lancée lors d'une erreur sql
		 */
		@Override
	    public void loadLibrabyBooks() throws StorageException {	
			try(PreparedStatement stmt = connection.prepareStatement(LOAD_LIBRABYBOOKS)) { 
				stmt.setInt(1, matriculeAuthor);
				
	    		try(final ResultSet rs = stmt.executeQuery()){
	    			Map<Book, Integer> librabyBooks = new HashMap<Book, Integer>();			
					while(rs.next()) {
						String title = rs.getString("title");	
						String isbn = rs.getString("isbn");
						String description = rs.getString("description");
						int matriculeAuthor = rs.getInt("matricule");
						Author author = loadAuthor(matriculeAuthor);
						boolean isPublished = rs.getBoolean("isPublished");
						
						
						librabyBooks.put(new Book(author, title, new Isbn(isbn), description, isPublished, null), rs.getInt("idBook"));
					}
					
					this.libraryBooks.setLibrabyBooks(librabyBooks);
	    		}		
	    		
	    		
			} catch (SQLException e) {
				throw new StorageException("Erreur lors de la récupération des livres \n");
			}  	    		
	    }
	        		    
	    /**
	     * Méthode qui permet de load toutes les pages liées à un livre
	     * @param idBook int id du livre
	     * @return SortedSet<Page> ensemble des pages du livre
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
		@Override
	    public List<Page> loadPages(Book book) throws StorageException {
	    	int idBook = libraryBooks.getLibrabyBooks().get(book);	
	    	try(PreparedStatement stmt = connection.prepareStatement(LOAD_PAGES)) {      		
				stmt.setInt(1, idBook);
	    		 
	    		try(ResultSet rs = stmt.executeQuery()){
	    			List<Page> pageList = new ArrayList <Page>();			
					while(rs.next()) {
						int numPage = rs.getInt("numPage");
						String textPage = rs.getString("textPage");
						List<Choice> choiceList = loadChoice(numPage, idBook);
						pageList.add(new Page(numPage, textPage, choiceList));
					}					
					return pageList;
	    		}						
			} catch (SQLException e) {
				throw new StorageException("Erreur lors de la lecture des pages. " + e.getMessage() + "\n");
			}	    		
	    }
	    
	    /**
	     * Méthode qui permet de load les tous les choix liés à une page
	     * @param numPage int numéro de la page
	     * @return List<Choice> ensemble des choix liés au livre
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
	    private List<Choice> loadChoice(int numPage, int idBook) throws StorageException{
	    	try(PreparedStatement stmt = connection.prepareStatement(LOAD_CHOICES)) {      		
				stmt.setInt(1, numPage);
				stmt.setInt(2, idBook);
				
	    		try(ResultSet rs = stmt.executeQuery()){
	    			List<Choice> choiceList = new ArrayList <Choice>();			
					while(rs.next()) {
						int numChoice = rs.getInt("numChoice");
						String textPage = rs.getString("textChoice");					
						int numFromPageLoad = rs.getInt("numFromPage");
						int numGoPage = rs.getInt("numGoPage");
						
						choiceList.add(new Choice(numChoice, textPage, numFromPageLoad, numGoPage));
					}
					return choiceList;
	    		}						
			} catch (SQLException e) {
				throw new StorageException("Erreur lors de la lecture des choix " + e.getMessage() + " \n");
			}  	    		
	    }
		
	    /**
	     * Méthode qui permet de load un auteur dans la base de données
	     * @param matricule int matricule de l'auteur
	     * @return Author qui est l'auteur à qui correspond le matricule
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
		private Author loadAuthor(int matricule) throws StorageException {  
			try(PreparedStatement stmt = connection.prepareStatement(LOAD_AUTHOR)) {      		
				stmt.setInt(1, matricule);
				
	    		try(ResultSet rs = stmt.executeQuery()){
	    			int matriculeAu = 0;
					String firstName = "";
					String name = "";
					
					while(rs.next()) {
						 matriculeAu = rs.getInt("matricule");
						 firstName = rs.getString("firstName");
						 name = rs.getString("name");
						
					}					
					return new Author(firstName, name, matriculeAu);
	    		}					
			}catch (SQLException e) {
				throw new StorageException("ERREUR LORS DE LA LECTURE DANS LA BD : " + e.getMessage() + " \n");
			}  	  		    		    
	    }
			
	    /**
	     * Méthode qui permet de vérifier si un auteur existe déjà dans la base de données
	     * @param author AuhtorDto qui est l'auteur dont on veut vérifier la présence
	     * @return Boolean, true si l'auteur existe déjà sinon false
	     * @throws SQLException Exception lancée lors d'une erreur sql
	     */
	    private boolean checkIfAurthorExist(Author author) throws StorageException {	    
	    	try(PreparedStatement stmt = connection.prepareStatement(CHECK_AUTHOR)) {      
				stmt.setInt(1, author.getMatricule());
				
	    		try(ResultSet rs = stmt.executeQuery()){
	    			return rs.next();
	    		}
					
	    	}catch (SQLException e) {
	    		throw new StorageException("Erreur lors de la recherche de l'auteur dans la BD. \n");
			}
	    }
	    
	    /**
	     * Méthode qui permet de savoir si un numéro isbn est déjà utilisé
	     * par un autre livre
	     * @param isbn String qui est le numéro isbn du livre
	     * @return true si le numéro isbn est déjà utilisé sinon false
	     * @throws StorageException Exception lancée en cas d'erreur lors de la requête sql
	     */
		@Override
		public boolean checkIfIsbnExist(String isbn) throws StorageException {
			try(PreparedStatement stmt = connection.prepareStatement(CHECK_ISBN_EXIST)) {      		
				stmt.setString(1, isbn);
				
	    		try(ResultSet rs = stmt.executeQuery()){
	    			return rs.next();
	    		}			
	    	}catch (SQLException e) {
	    		throw new StorageException("Erreur lors de la recherche du numéro Isbn. \n");
			}
		}

		/**
		 * Méthode qui permet de mettre à jour un livre dans 
		 * la libraryBooks
		 * @param Book le livre que l'on veut mettre à jour
		 */
		@Override
		public void updateBookLibrary(Book book) {
			this.libraryBooks.getLibrabyBooks().replace(book, this.libraryBooks.getLibrabyBooks().get(book));
		}
		
	   @Override
	    public void close() {
	        try {
	            connection.close();
	        } catch (SQLException ex) {
	            throw new StorageException("Erreur lors de la fermeture de la connexion. \n");
	        }
	    }
}
